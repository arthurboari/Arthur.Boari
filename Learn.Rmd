---
title: "Learning R"
author: "Arthur Boari"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 1
    #code_folding: hide
---
O conteúdo desta página do blog é originado do curso [Learn ggplot2 in R for Data Visualization 2021](https://www.udemy.com/course/learn-ggplot2-in-r-for-data-viz/).

# Comandos utéis

2022 | 01 | 10 Last compiled: `r Sys.Date()`

Nessa seção iremos compilar algumas funções úteis.

A primeira função é *dir*. Ela listará os arquivos presentes no nosso diretório de projeto ou a pasta. Veja o exemplo abaixo:

```{r}
getwd() #essa função descreve o caminho do meu diretório de trabalho
dir() #aqui teremos a lista com os arquivos e pastas do diretório de trabalho
```

A segunda função é *ls*, que lista os objetos presentes no nosso ambiente global (Global Environment).
```{r}
ls() #essa função descreve os objetos presentes no Global Environment
objects() #mesma função que *ls()*
```

A terceira função é *remove*, e será útil para remover algum objeto do Global Environment.
```{r echo=TRUE, message=TRUE, warning=TRUE}
#Vamos criar dois objetos
a<-1
b<-2
#Vamos listá-los
ls()
#Vamos remover o objeto *a*
remove(a)
#Vamos listá-los
objects()
#Vamos remover o objeto *b*
rm(b)
#Vamos listá-los
objects()
```

A quarta função é *print*, e como o nome sugere, irá imprimir no Console algum texto ou conteúdo de alguma variável. Veja o exemplo abaixo:
```{r}
x<-"hello world!"
print(x)
#também podemos apenas chamar o objeto
x #irá retornar a mesma resposta
print("hello world") #outra forma
#como imprimir textos mais complexos?
cat("o valor da área do triângulo é", 135, "cm^2")
print(paste("o valor da área do triângulo é", 135, "cm^2"))
```

A quinta função é a *install.packages*, que instalará os pacotes no nosso R. O nome do pacote deve ser uma *string*, ou seja, texto!
```{r eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
install.packages("ggplot2")
```

A sexta função é *library*, que carregará o pacote instalado.
```{r echo=TRUE, message=TRUE, warning=TRUE}
library(ggplot2)
require(ggplot2)
```

A diferença entre *library* e *require* é que a segunda é a mais indicada pára implementação de funções que necessitam de funções de outros pacotes para operar.

# ESTRUTURAS NO R:

2022 | 01 | 10 Last compiled: `r Sys.Date()`

As estruturas do R podem ser classificadas quanto ao tipo de variável e quanto a estrutura utilizada.

* Quanto ao tipo de variável/classe:
  + Character (ou charactere/texto);
  + Numeric (numérico - seja discreto (integer, e.g. 1, 2,3) ou contínuo, e.g. 1.2,3.7,5.5);
  + Complex (números complexos, e.g. 2 + 5i);
  + Logical (lógicos ou booleanos, e.g. TRUE ou FALSE / 1 ou 0).

Note: o R entenderá sempre qualquer variável numérico como do tipo *double*, ou seja, tratará como discreto mesmo que não há informações sobre osa decimais. Para assimilar um número inteiro, utilize o caractere **L** após o número, como demonstrado abaixo. Para mais detalhes, leia o conteúdo desta [página](https://faculty.nps.edu/sebuttre/home/R/data.html).

```{r echo=TRUE, message=TRUE, warning=TRUE}
x<-23L
print(x)
typeof(x) #verifica o tipo do objeto
class(x) #mesmo objetivo da função *typeof*
y<-23
print(y)
typeof(y)
class(y)
```

Observe que as duas formas produzem o mesmo resultado no console, mas a forma de armzenagem é diferente.

* Quanto ao tipo de estrutura:
 
  + Vector (vetor);
  + List (lista);
  + Matrix (matriz);
  + Array;
  + Dataframes.
  
# Vetores

2022 | 01 | 10 Last compiled: `r Sys.Date()`

Podem ser definidos como **uma coleção de elementos de uma mesma classe** e podem ser criados de duas maneiras:

## Através da função concatenar *c*

Essa função apenas irá propiciar a assimilação de mais de um valor por vez. Veja o exemplo abaixo:

```{r eval=FALSE, include=TRUE}
?c #solicita o *help* da função
# Note que é a terceira letra do alfabeto na forma minúscula! O R é **case sensitive**, ou seja, *c* e *C* são completamente diferentes e isso vale para qualquer código aplicado ao R.
```
```{r}
x<-c(1,2,3,4,5,6,7,8,9,10)
print(x)
```

## Através da função *vector*

Essa função é ideal para quando se necessita de um vetor pré-criado vazio. Veja o exemplo abaixo:

```{r eval=FALSE, include=TRUE}
?vector #solicita o *help* da função
```

```{r echo=TRUE}
y<-vector(mode = "numeric",length = 5)
print(y)
#podemos fazer operações com ele
y+1
y-1
```

### Funções úteis ao trabalhar com vetor:

#### Função *is.vector*

Essa função realiza a checagem do estrutura do objeto a partir da lógica. Observe:

```{r}
is.vector(y)
```

Com o resultado sendo **TRUE**, temos que sim, o objeto *y* é um vetor.

#### Função *as.vector*

Essa função serve para transformar uma estrutura em vetor.

```{r}
x <- c(a = 1, b = 2) # esse vetor tem as posições nomeadas
print(x)
# O objeto *x* é um vetor?
is.vector(x)
# Transforme o objeto *x* em um vetor
as.vector(x)
# Os objetos *x* e *as.vector(x)* são iguais?
all.equal(x, as.vector(x))
```

O resultado da última função nos diz que, embora o conteúdo dos vetores sejam iguais, eles se diferenciam quanto a nomeação dos valores.

## Acessando valores de um vetor

Para acessar qualquer valor de um vetor, usamos colchetes. Veja o exemplo abaixo:

```{r}
#Vamos criar o vetor
x<-1:10 #aqui os dois pontos significam até, ou seja, irá criar uma sequência de 1 a 10, um-a-um elemento
print(x)
#Vamos acessar o número 1: ele está na primeira posição do vetor, então:
x[1] # não existe posição 0 em vetores na linguagem R
#Para acessar o sexto elemento do vetor, usamos:
x[6]
#Acessando as posições 1 e 6 simultaneamente
x[c(1,6)]
#Acessando uma sequência de posições
x[8:10]
#Criando ouro vetor
y<-c("Arthur","Rezende","Boari")
print(y)
#Como o meu nome não tem "Rezende", vamos acessar o vetor *y* de forma que escreva o meu nome corretamente
y[c(T,F,T)]
#Modificando uma posição do vetor, suponhamos que *Rezende* se escreve com *s*
y[2]<-"Resende"
print(y)
```

Note: dentro dos conchetes esquevemos a **posição** que almejamos acessar, e não o valor que queremos. Podemos acessar através de um vetor lógico, também.

**COERÇÃO**: ocorre quando se misturam variáveis de diferentes classes em um mesmo objeto. Veja abaixo:

```{r}
v<- c(1,TRUE) #aqui misturamos numérico com lógico
v # vemos que converteu TRUE em numérico
class(v)
v<-c(FALSE,"TRUE")
v # aqui ele converteu a character
class(v)
```

Veja que o R decidiu a classe do objeto e, por isso, tenha bastante cuidado ao trabalhar com vetores.

## Comparando vetores

Comparar vetores é de grande utilidade. Veremos como fazer isso:

```{r}
#Criando dois vetores
v1<-1:10
v2<-10:1
print(v1);print(v2)

#Podemos utilizar operadores matemáticos para realizar as comparações
v1 == v2 # os vetores são iguais?
v1 != v2 # os vetores são diferentes?
v1 > v2 # o vetor *v1* é maior que o vetor *v2*?
v1 < v2 # o vetor *v1* é menor que o vetor *v2*?

#Podemos utilizar a função *identical*
#Nesse caso, devemos garantir que *v1* e *v2* possuem a mesma classe
class(v1);class(v2)

#Como possuem a mesma classe, podemos usar a função:
identical(v1,v2)
```

## Operação com vetores

Utilizando os vetores *v1* e *v2* definidos acima, temos:

```{r}
#soma
v1 + v2 
#subtração
v1 - v2 
#multiplicação
v1 * v2 
#divisão
v1/v2
```

Em alguns casos os vetores não terão o mesmo tamanho:

```{r message=TRUE, warning=TRUE}
#Verificando o tamanho dos vetores *v1* e *v2*
length(v1);length(v2)

#Criando vetores de tamanhos diferentes:
v1<-1:3
v2<-4:5
length(v1);length(v2)

#Vamos realizar apenas a soma dos vetores para ver como o R irá se comportar:
v1 + v2

# Para obter os valores acima tivemos:
  # 1 2 3 (v1)
  # 4 5 x (v2)
  # 5 7 7 (resultado)

#Para que o terceiro elemento da soma retorne 7, x deve ser igual a 4

#Podemos criar um vetor a partir da junção de dois
v<-c(v1,v2)
print(v)
```

Quando trabalhamos com vetores de tamanhos diferentes, os elementos do menor vetor serão repetidos até que os vetores tenham o mesmo tamanho. E esse comportamento é automático. Mais uma vez o R toma uma decisão por nós!

# Lists

2022 | 01 | 10 Last compiled: `r Sys.Date()`